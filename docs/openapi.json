{
  "openapi": "3.1.0",
  "info": {
    "title": "PrivateGPT",
    "summary": "PrivateGPT Summary",
    "description": "## PrivateGPT\n\nPrivateGPT provides an **API** containing all the building blocks required to build \n**private, context-aware AI applications**. The API follows and extends OpenAI API standard, and supports\nboth normal and streaming responses.\n\nThe API is divided in two logical blocks: \n- High-level API, abstracting all the complexity of a RAG (Retrieval Augmented Generation) pipeline implementation:\n  - Ingestion of documents: internally managing document parsing, splitting, metadata extraction, \nembedding generation and storage.\n  - Chat & Completions using context from ingested documents: abstracting the retrieval of context, the prompt\nengineering and the response generation. \n- Low-level API, allowing advanced users to implement their own complex pipelines:\n  - Embeddings generation: based on a piece of text. \n  - Contextual chunks retrieval: given a query, returns the most relevant chunks of text from the ingested\ndocuments.\n\nA working **Gradio UI client** is provided to test the API, together with a set of useful tools such as bulk \nmodel download script, ingestion script, documents folder watch, etc.\n\n> By checking the codebase you'll notice PrivateGPT is engineered following best software development \npractices as it is intended for production use.\n\n## Installation and Settings\n\n### (Optional) Enable a virtual environment\n\nIt is strongly recommended to use a virtual Python environment to avoid problems with dependencies and Python versions.\nUse any virtual environment tool of your choice - we recommend [pyenv](https://github.com/pyenv/pyenv). \n\n### Base requirements to run PrivateGPT\n\n* Python 3.11\n* Poetry: https://python-poetry.org/docs/\n* [Optional] Install `make` for scripts:\n  windows: (Using chocolatey) `choco install make`\n  osx: (Using homebrew): `brew install make`\n\n### Install dependencies\n\nInstall the dependencies:\n\n```bash\npoetry install --with ui\n```\n\nVerify everything is working by running `make run` (or `poetry run python -m private_gpt`) and navigate to\nhttp://localhost:8001. You should see a [Gradio](https://gradio.app/) UI configured with a mock LLM that will\necho back the input.\n\n### Settings\n\n> Note: the default settings of PrivateGPT work out-of-the-box for a 100% local setup. Skip this section if you just\nwant to test PrivateGPT locally, and come back later to learn about the extensibility options. \n\nPrivateGPT is configured through *profiles* that are defined using yaml files, and selected through env variables.\nThe full list of properties configurable can be found in `settings.yaml`\n\n#### env var `PGPT_SETTINGS_FOLDER`\n\nThe location of the settings folder. Defaults to the root of the project.\nShould contain the default `settings.yaml` and any other `settings-{profile}.yaml`. \n\n#### env var `PGPT_PROFILES`\n\nBy default, the profile definition in `settings.yaml` is loaded.\nUsing this env var you can load additional profiles; format is a comma separated list of profile names.\nThis will merge `settings-{profile}.yaml` on top of the base settings file.\n\nFor example:\n`PGPT_PROFILES=local,cuda` will load `settings-local.yaml`\nand `settings-cuda.yaml`, their contents will be merged with\nlater profiles properties overriding values of earlier ones like `settings.yaml`.\n\nDuring testing, the `test` profile will be active along with the default, therefore `settings-test.yaml`\nfile is required.\n\n#### Environment variables expansion\n\nConfiguration files can contain environment variables,\nthey will be expanded at runtime.\n\nExpansion must follow the pattern `${VARIABLE_NAME:default_value}`.\n\nFor example, the following configuration will use the value of the `PORT`\nenvironment variable or `8001` if it's not set.\nMissing variables with no default will produce an error.\n\n```yaml\nserver:\n  port: ${PORT:8001}\n```\n\n### Local LLM requirements\n\nFor PrivateGPT to run fully locally GPU acceleration is required\n(CPU execution is possible, but very slow), however,\ntypical Macbook laptops or window desktops with mid-range GPUs lack VRAM to run\neven the smallest LLMs. For that reason\n**local execution is only supported for models compatible with [llama.cpp](https://github.com/ggerganov/llama.cpp)**\n\nThese two models are known to work well:\n\n* https://huggingface.co/TheBloke/Llama-2-7B-chat-GGUF\n* https://huggingface.co/TheBloke/Mistral-7B-Instruct-v0.1-GGUF (recommended)\n\nTo ease the installation process, use the `setup` script that will download both\nthe embedding and the LLM model and place them in the correct location (under `models` folder):\n\n```bash\npoetry run python scripts/setup\n```\n\nInstall extra dependencies for local execution:\n\n```bash\npoetry install --with local\n```\n\nIf you are ok with CPU execution, you can skip the rest of this section.\n\n#### OSX GPU support\n\nYou will need to build `llama.cpp` with metal support. to do that run:\n\n```bash\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" pip install --force-reinstall --no-cache-dir llama-cpp-python\n```\n\n#### Windows GPU support\n\nWindows GPU support is done through CUDA or similar open source technologies.\nFollow the instructions on the original [llama.cpp](https://github.com/ggerganov/llama.cpp) repo to install the required\ndependencies.\n\nSome tips to get it working with an NVIDIA card and CUDA:\n\n* Install latest VS2022 (and build tools) https://visualstudio.microsoft.com/vs/community/\n* Install CUDA toolkit https://developer.nvidia.com/cuda-downloads\n* [Optional] Install CMake to troubleshoot building issues by compiling llama.cpp directly https://cmake.org/download/\n\nIf you have all required dependencies properly configured running the\nfollowing powershell command should succeed.\n\n```powershell\n$env:CMAKE_ARGS='-DLLAMA_CUBLAS=on'; poetry run pip install --force-reinstall --no-cache-dir llama-cpp-python\n```\n\nIf your installation was correct, you should see a message similar to the following next\ntime you start the server `BLAS = 1`.\n\n```\nllama_new_context_with_model: total VRAM used: 4857.93 MB (model: 4095.05 MB, context: 762.87 MB)\nAVX = 1 | AVX2 = 1 | AVX512 = 0 | AVX512_VBMI = 0 | AVX512_VNNI = 0 | FMA = 1 | NEON = 0 | ARM_FMA = 0 | F16C = 1 | FP16_VA = 0 | WASM_SIMD = 0 | BLAS = 1 | SSE3 = 1 | SSSE3 = 0 | VSX = 0 | \n```\n\n#### Linux GPU support\n\n\ud83d\udea7 Under construction \ud83d\udea7 \n\n## Running the Server\n\nAfter following the installation steps you should be ready to go. Here are some common run setups:\n\n### Running 100% locally\n\nMake sure you have followed the *Local LLM requirements* section before moving on.\n\nThis command will start PrivateGPT using the `settings.yaml` (default profile) together with the `settings-local.yaml`\nconfiguration files. By default, it will enable both the API and the Gradio UI. Run:\n\n```\nPGPT_PROFILES=local make run\n``` \n\nor \n\n```\nPGPT_PROFILES=local poetry run python -m private_gpt\n```\n\nWhen the server is started it will print a log *Application startup complete*. \nNavigate to http://localhost:8001 to use the Gradio UI or to http://localhost:8001/docs (API section)to try the API \nusing Swagger UI.\n\n### Local server using OpenAI as LLM\n\nIf you cannot run a local model (because you don't have a GPU, for example) or for testing purposes, you may\ndecide to run PrivateGPT using OpenAI as the LLM. \n\nIn order to do so, create a profile `settings-openai.yaml` with the following contents:\n\n```yaml\nllm:\n  mode: openai  \n\nopenai:\n  api_key: <your_openai_api_key>  # You could skip this configuration and use the OPENAI_API_KEY env var instead\n```\n\nAnd run PrivateGPT loading that profile you just created:\n\n```PGPT_PROFILES=openai make run``` \n\nor \n\n```PGPT_PROFILES=openai poetry run python -m private_gpt```\n\n> Note this will still use the local Embeddings model, as it is ok to use it on a CPU. \nWe'll support using OpenAI embeddings in a future release.\n\nWhen the server is started it will print a log *Application startup complete*. \nNavigate to http://localhost:8001 to use the Gradio UI or to http://localhost:8001/docs (API section) to try the API. \nYou'll notice the speed and quality of response is higher, given you are using OpenAI's LLM. \n\n### Use AWS's Sagemaker\n\n\ud83d\udea7 Under construction \ud83d\udea7 \n\n## Gradio UI user manual\n\n\ud83d\udea7 Under construction \ud83d\udea7 \n\n## Deployment options\n\n\ud83d\udea7 We are working on Dockerized deployment guidelines \ud83d\udea7 \n\n## Ingesting local documents\n\nWhen you are running PrivateGPT in a fully local setup, you can ingest a full folder (containing pdf, text files, etc.) \nand optionally watch changes on it with the command:\n\n```bash\nmake ingest /path/to/folder -- --watch\n```\n\nAfter ingestion is complete, you should be able to chat with your documents\nby navigating to http://localhost:8001 and using the option `Query documents`, \nor using the completions / chat API.\n\n## API\n\nAs explained in the introduction, the API contains high level APIs (ingestion and chat/completions) and low level APIs\n(embeddings and chunk retrieval). In this section the different specific API calls are explained:",
    "contact": {
      "url": "https://github.com/imartinez/privateGPT"
    },
    "license": {
      "name": "Apache 2.0",
      "url": "https://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "version": "0.1.0"
  },
  "paths": {
    "/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Health",
        "description": "Blavla",
        "operationId": "health_health_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Health Health Get"
                }
              }
            }
          }
        }
      }
    },
    "/v1/completions": {
      "post": {
        "tags": [
          "Completions"
        ],
        "summary": "Completion",
        "description": "We recommend most users use our Chat completions API.\n\nGiven a prompt, the model will return one predicted completion. If `use_context` is\nset to `true`, the model will use context coming from the ingested documents to create the response. The\ndocuments being used can be filtered using the `context_filter` and passing the document IDs to be used.\nIngested documents IDs can be found using `/ingest/list` endpoint. If you want all ingested documents to be\nused, remove `context_filter` altogether.\n\nWhen using `'stream': true`, the API will return data chunks following\n[OpenAI's streaming model](https://platform.openai.com/docs/api-reference/chat/streaming):\n```\n{\"id\":\"12345\",\"object\":\"completion.chunk\",\"created\":1694268190,\n\"model\":\"private-gpt\",\"choices\":[{\"index\":0,\"delta\":{\"content\":\"Hello\"},\"finish_reason\":null}]}\n```",
        "operationId": "prompt_completion_v1_completions_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompletionsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OpenAICompletion"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/chat/completions": {
      "post": {
        "tags": [
          "Completions"
        ],
        "summary": "Chat Completion",
        "description": "Given a list of messages comprising a conversation, the model will return a response. If `use_context` is\nset to `true`, the model will use context coming from the ingested documents to create the response. The\ndocuments being used can be filtered using the `context_filter` and passing the document IDs to be used.\nIngested documents IDs can be found using `/ingest/list` endpoint. If you want all ingested documents to be\nused, remove `context_filter` altogether.\n\nWhen using `'stream': true`, the API will return data chunks following\n[OpenAI's streaming model](https://platform.openai.com/docs/api-reference/chat/streaming):\n```\n{\"id\":\"12345\",\"object\":\"completion.chunk\",\"created\":1694268190,\n\"model\":\"private-gpt\",\"choices\":[{\"index\":0,\"delta\":{\"content\":\"Hello\"},\"finish_reason\":null}]}\n```",
        "operationId": "chat_completion_v1_chat_completions_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OpenAICompletion"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/chunks": {
      "post": {
        "tags": [
          "Context Chunks"
        ],
        "summary": "Chunks Retrieval",
        "operationId": "chunks_retrieval_v1_chunks_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChunksBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChunksResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/ingest": {
      "post": {
        "tags": [
          "Ingestion"
        ],
        "summary": "Ingest",
        "operationId": "ingest_v1_ingest_post",
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_ingest_v1_ingest_post"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IngestResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/ingest/list": {
      "get": {
        "tags": [
          "Ingestion"
        ],
        "summary": "List Ingested",
        "operationId": "list_ingested_v1_ingest_list_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/IngestedDoc"
                  },
                  "type": "array",
                  "title": "Response List Ingested V1 Ingest List Get"
                }
              }
            }
          }
        }
      }
    },
    "/v1/embeddings": {
      "post": {
        "tags": [
          "Embeddings"
        ],
        "summary": "Embeddings Generation",
        "operationId": "embeddings_generation_v1_embeddings_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbeddingsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Body_ingest_v1_ingest_post": {
        "properties": {
          "file": {
            "type": "string",
            "format": "binary",
            "title": "File"
          }
        },
        "type": "object",
        "required": [
          "file"
        ],
        "title": "Body_ingest_v1_ingest_post"
      },
      "ChatBody": {
        "properties": {
          "messages": {
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            },
            "type": "array",
            "title": "Messages"
          },
          "use_context": {
            "type": "boolean",
            "title": "Use Context",
            "default": false
          },
          "stream": {
            "type": "boolean",
            "title": "Stream",
            "default": false
          },
          "context_filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ContextFilter"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "messages"
        ],
        "title": "ChatBody",
        "examples": [
          {
            "messages": [
              {
                "content": "How do you fry an egg?",
                "role": "user"
              }
            ],
            "stream": false,
            "use_context": false
          }
        ]
      },
      "Chunk": {
        "properties": {
          "score": {
            "type": "number",
            "title": "Score"
          },
          "document": {
            "$ref": "#/components/schemas/IngestedDoc"
          },
          "text": {
            "type": "string",
            "title": "Text"
          },
          "previous_texts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Previous Texts"
          },
          "next_texts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Texts"
          }
        },
        "type": "object",
        "required": [
          "score",
          "document",
          "text",
          "previous_texts",
          "next_texts"
        ],
        "title": "Chunk"
      },
      "ChunksBody": {
        "properties": {
          "text": {
            "type": "string",
            "title": "Text"
          },
          "context_filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ContextFilter"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 10
          },
          "prev_next_chunks": {
            "type": "integer",
            "title": "Prev Next Chunks",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "text"
        ],
        "title": "ChunksBody"
      },
      "ChunksResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "object": {
            "type": "string",
            "title": "Object"
          },
          "created": {
            "type": "integer",
            "title": "Created"
          },
          "model": {
            "type": "string",
            "title": "Model"
          },
          "chunks": {
            "items": {
              "$ref": "#/components/schemas/Chunk"
            },
            "type": "array",
            "title": "Chunks"
          }
        },
        "type": "object",
        "required": [
          "id",
          "object",
          "created",
          "model",
          "chunks"
        ],
        "title": "ChunksResponse"
      },
      "CompletionsBody": {
        "properties": {
          "prompt": {
            "type": "string",
            "title": "Prompt"
          },
          "use_context": {
            "type": "boolean",
            "title": "Use Context",
            "default": false
          },
          "context_filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ContextFilter"
              },
              {
                "type": "null"
              }
            ]
          },
          "stream": {
            "type": "boolean",
            "title": "Stream",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "prompt"
        ],
        "title": "CompletionsBody"
      },
      "ContextFilter": {
        "properties": {
          "docs_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Docs Ids"
          }
        },
        "type": "object",
        "title": "ContextFilter"
      },
      "Embedding": {
        "properties": {
          "index": {
            "type": "integer",
            "title": "Index"
          },
          "object": {
            "type": "string",
            "title": "Object"
          },
          "embedding": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Embedding"
          }
        },
        "type": "object",
        "required": [
          "index",
          "object",
          "embedding"
        ],
        "title": "Embedding"
      },
      "EmbeddingsBody": {
        "properties": {
          "input": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Input"
          }
        },
        "type": "object",
        "required": [
          "input"
        ],
        "title": "EmbeddingsBody"
      },
      "EmbeddingsResponse": {
        "properties": {
          "object": {
            "type": "string",
            "title": "Object"
          },
          "model": {
            "type": "string",
            "title": "Model"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Embedding"
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "required": [
          "object",
          "model",
          "data"
        ],
        "title": "EmbeddingsResponse"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "IngestResponse": {
        "properties": {
          "object": {
            "type": "string",
            "title": "Object"
          },
          "model": {
            "type": "string",
            "title": "Model"
          },
          "documents": {
            "items": {
              "$ref": "#/components/schemas/IngestedDoc"
            },
            "type": "array",
            "title": "Documents"
          }
        },
        "type": "object",
        "required": [
          "object",
          "model",
          "documents"
        ],
        "title": "IngestResponse"
      },
      "IngestedDoc": {
        "properties": {
          "doc_id": {
            "type": "string",
            "title": "Doc Id"
          },
          "doc_metadata": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Doc Metadata"
          }
        },
        "type": "object",
        "required": [
          "doc_id"
        ],
        "title": "IngestedDoc"
      },
      "OpenAIChoice": {
        "properties": {
          "finish_reason": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Finish Reason",
            "examples": [
              "stop"
            ]
          },
          "delta": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OpenAIDelta"
              },
              {
                "type": "null"
              }
            ]
          },
          "message": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OpenAIMessage"
              },
              {
                "type": "null"
              }
            ]
          },
          "index": {
            "type": "integer",
            "title": "Index",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "finish_reason"
        ],
        "title": "OpenAIChoice",
        "description": "Response from AI.\n\nEither the delta or the message will be present, but never both."
      },
      "OpenAICompletion": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "object": {
            "type": "string",
            "enum": [
              "completion",
              "completion.chunk"
            ],
            "title": "Object",
            "default": "completion"
          },
          "created": {
            "type": "integer",
            "title": "Created",
            "examples": [
              1623340000
            ]
          },
          "model": {
            "type": "string",
            "enum": [
              "private-gpt"
            ],
            "title": "Model"
          },
          "choices": {
            "items": {
              "$ref": "#/components/schemas/OpenAIChoice"
            },
            "type": "array",
            "title": "Choices"
          }
        },
        "type": "object",
        "required": [
          "id",
          "created",
          "model",
          "choices"
        ],
        "title": "OpenAICompletion",
        "description": "Clone of OpenAI Completion model.\n\nFor more information see: https://platform.openai.com/docs/api-reference/chat/object"
      },
      "OpenAIDelta": {
        "properties": {
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content"
          }
        },
        "type": "object",
        "required": [
          "content"
        ],
        "title": "OpenAIDelta",
        "description": "A piece of completion that needs to be concatenated to get the full message."
      },
      "OpenAIMessage": {
        "properties": {
          "role": {
            "type": "string",
            "enum": [
              "assistant",
              "system",
              "user"
            ],
            "title": "Role",
            "default": "user"
          },
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content"
          }
        },
        "type": "object",
        "required": [
          "content"
        ],
        "title": "OpenAIMessage",
        "description": "Inference result, with the source of the message.\n\nRole could be the assistant or system\n(providing a default response, not AI generated)."
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      }
    }
  },
  "tags": [
    {
      "name": "Ingestion",
      "description": "High-level APIs covering document ingestion -internally managing document parsing, splitting, metadata extraction, embedding generation and storage- and ingested documents CRUD. Each ingested document is identified by an ID that can be used to filter the context used in *Completions* and *Chunks* APIs."
    },
    {
      "name": "Completions",
      "description": "High-level APIs covering Chat and Completions. They follow OpenAI's format, extending it to allow using the context coming from ingested documents to create the response. Internally manage context retrieval, prompt engineering and the response generation."
    },
    {
      "name": "Context Chunks",
      "description": "Low-level API that given a query return relevant chunks of text coming from the ingested documents."
    },
    {
      "name": "Embeddings",
      "description": "Low-level API to obtain the vector representation of a given text, using an Embeddings model. Follows OpenAI's embeddings API format."
    },
    {
      "name": "Health",
      "description": "Simple health API to make sure the server is up and running."
    }
  ]
}